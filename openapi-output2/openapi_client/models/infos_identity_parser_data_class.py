# coding: utf-8

"""
Eden AI

Your project description

The version of the OpenAPI document: 2.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.country import Country
from openapi_client.models.item_identity_parser_data_class import (
    ItemIdentityParserDataClass,
)
from typing import Set
from typing_extensions import Self


class InfosIdentityParserDataClass(BaseModel):
    """
    InfosIdentityParserDataClass
    """  # noqa: E501

    last_name: ItemIdentityParserDataClass
    given_names: Optional[List[ItemIdentityParserDataClass]] = None
    birth_place: ItemIdentityParserDataClass
    birth_date: ItemIdentityParserDataClass
    issuance_date: ItemIdentityParserDataClass
    expire_date: ItemIdentityParserDataClass
    document_id: ItemIdentityParserDataClass
    issuing_state: ItemIdentityParserDataClass
    address: ItemIdentityParserDataClass
    age: ItemIdentityParserDataClass
    country: Country
    document_type: ItemIdentityParserDataClass
    gender: ItemIdentityParserDataClass
    image_id: Optional[List[ItemIdentityParserDataClass]] = None
    image_signature: Optional[List[ItemIdentityParserDataClass]] = None
    mrz: ItemIdentityParserDataClass
    nationality: ItemIdentityParserDataClass
    __properties: ClassVar[List[str]] = [
        "last_name",
        "given_names",
        "birth_place",
        "birth_date",
        "issuance_date",
        "expire_date",
        "document_id",
        "issuing_state",
        "address",
        "age",
        "country",
        "document_type",
        "gender",
        "image_id",
        "image_signature",
        "mrz",
        "nationality",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InfosIdentityParserDataClass from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of last_name
        if self.last_name:
            _dict["last_name"] = self.last_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in given_names (list)
        _items = []
        if self.given_names:
            for _item in self.given_names:
                if _item:
                    _items.append(_item.to_dict())
            _dict["given_names"] = _items
        # override the default output from pydantic by calling `to_dict()` of birth_place
        if self.birth_place:
            _dict["birth_place"] = self.birth_place.to_dict()
        # override the default output from pydantic by calling `to_dict()` of birth_date
        if self.birth_date:
            _dict["birth_date"] = self.birth_date.to_dict()
        # override the default output from pydantic by calling `to_dict()` of issuance_date
        if self.issuance_date:
            _dict["issuance_date"] = self.issuance_date.to_dict()
        # override the default output from pydantic by calling `to_dict()` of expire_date
        if self.expire_date:
            _dict["expire_date"] = self.expire_date.to_dict()
        # override the default output from pydantic by calling `to_dict()` of document_id
        if self.document_id:
            _dict["document_id"] = self.document_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of issuing_state
        if self.issuing_state:
            _dict["issuing_state"] = self.issuing_state.to_dict()
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict["address"] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of age
        if self.age:
            _dict["age"] = self.age.to_dict()
        # override the default output from pydantic by calling `to_dict()` of country
        if self.country:
            _dict["country"] = self.country.to_dict()
        # override the default output from pydantic by calling `to_dict()` of document_type
        if self.document_type:
            _dict["document_type"] = self.document_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of gender
        if self.gender:
            _dict["gender"] = self.gender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in image_id (list)
        _items = []
        if self.image_id:
            for _item in self.image_id:
                if _item:
                    _items.append(_item.to_dict())
            _dict["image_id"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in image_signature (list)
        _items = []
        if self.image_signature:
            for _item in self.image_signature:
                if _item:
                    _items.append(_item.to_dict())
            _dict["image_signature"] = _items
        # override the default output from pydantic by calling `to_dict()` of mrz
        if self.mrz:
            _dict["mrz"] = self.mrz.to_dict()
        # override the default output from pydantic by calling `to_dict()` of nationality
        if self.nationality:
            _dict["nationality"] = self.nationality.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InfosIdentityParserDataClass from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "last_name": ItemIdentityParserDataClass.from_dict(obj["last_name"])
                if obj.get("last_name") is not None
                else None,
                "given_names": [
                    ItemIdentityParserDataClass.from_dict(_item)
                    for _item in obj["given_names"]
                ]
                if obj.get("given_names") is not None
                else None,
                "birth_place": ItemIdentityParserDataClass.from_dict(obj["birth_place"])
                if obj.get("birth_place") is not None
                else None,
                "birth_date": ItemIdentityParserDataClass.from_dict(obj["birth_date"])
                if obj.get("birth_date") is not None
                else None,
                "issuance_date": ItemIdentityParserDataClass.from_dict(
                    obj["issuance_date"]
                )
                if obj.get("issuance_date") is not None
                else None,
                "expire_date": ItemIdentityParserDataClass.from_dict(obj["expire_date"])
                if obj.get("expire_date") is not None
                else None,
                "document_id": ItemIdentityParserDataClass.from_dict(obj["document_id"])
                if obj.get("document_id") is not None
                else None,
                "issuing_state": ItemIdentityParserDataClass.from_dict(
                    obj["issuing_state"]
                )
                if obj.get("issuing_state") is not None
                else None,
                "address": ItemIdentityParserDataClass.from_dict(obj["address"])
                if obj.get("address") is not None
                else None,
                "age": ItemIdentityParserDataClass.from_dict(obj["age"])
                if obj.get("age") is not None
                else None,
                "country": Country.from_dict(obj["country"])
                if obj.get("country") is not None
                else None,
                "document_type": ItemIdentityParserDataClass.from_dict(
                    obj["document_type"]
                )
                if obj.get("document_type") is not None
                else None,
                "gender": ItemIdentityParserDataClass.from_dict(obj["gender"])
                if obj.get("gender") is not None
                else None,
                "image_id": [
                    ItemIdentityParserDataClass.from_dict(_item)
                    for _item in obj["image_id"]
                ]
                if obj.get("image_id") is not None
                else None,
                "image_signature": [
                    ItemIdentityParserDataClass.from_dict(_item)
                    for _item in obj["image_signature"]
                ]
                if obj.get("image_signature") is not None
                else None,
                "mrz": ItemIdentityParserDataClass.from_dict(obj["mrz"])
                if obj.get("mrz") is not None
                else None,
                "nationality": ItemIdentityParserDataClass.from_dict(obj["nationality"])
                if obj.get("nationality") is not None
                else None,
            }
        )
        return _obj
